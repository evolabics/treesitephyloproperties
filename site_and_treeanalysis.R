## Construct a 'perfect' dataset for a given phylogenetic tree. This tree is a random phylogeny
## with the rphylo command. Then, I get the subtrees and I generate sites that support each subtree
## The number of sites that support the subtree is analogous to the internal branch on which the
## the subtree is hanging.

## Then I generate errors in these "perfect sites". I do this by incorporating a probability of errors in copying
## the perfect sites.
## The whole alignment is binary in the beginning, but I convert it to pseudo-DNA. i.e. each site will still have
## two states, but they will be DNA states. I did this because the ML methods for tree reconstruction seem to work
## better for DNA (i.e., they report errors for binary states).
##
## I also generate a totally random dataset, i.e. the probability of having 1 or 0 is just 50-50.
## Then, I compare different metrics between these datasets
## Plot 1: the maximum likelihood score distribution per site
## Plot 2: the maximum likelihood tree of the 0.75 tree (this is the tree generated by a dataset where each character has a probability 0.75 to be the correct one and 0.25 to be not the ideal).
## Plot 3: the maximum likelihood tree of the totally random dataset
## Plot 4: the true tree (as it is produced by rtree)
## Plot 5: Parsimony score distributions
## Plot 6: In this plot I just concatenated the dataset "0.75" to produce a much larger (x20) dataset. The goal is to test how the bootstrap values change


## step 1: generate the tree
## and initialize the variables 
n = 30
birth = 0.5
death = 0.05
atree = rphylo(n, birth=0.5, death=0.05)
## all the subtrees of the tree
sb = subtrees(atree)
## the size of the alignment
alLen = 3000
## the datamatrix to store the dataset
dataMatrix = matrix(nrow=n, ncol=alLen)


totalTreeLength=0
## the proportion of each subtree. I have also
## kept some positions for storing the singletons
lenProps=array(0, dim=length(sb)+n)
## all the possible of sites, that support a subtree
patterns = matrix(0, nrow=n, ncol=length(sb)+n)
rownames(patterns) = atree$tip.label
rownames(dataMatrix) = atree$tip.label

## I get the patterns that match a subtree
## and I use the branch above the subtree (to the total branch length)
## as a proxy for the proportion of sites that should support this subtree
for( s in 1:length(sb)){
    mysb = sb[[s]]
    patterns[mysb$tip.label, s] = 1
    rootNode = max(sb[[s]]$node.label)
    totalTreeLength = totalTreeLength + atree$edge.length[which(atree$edge[,2] == rootNode)]
    lenProps[s] = atree$edge.length[which(atree$edge[,2] == rootNode)]
}

lenProps = lenProps/totalTreeLength
## I use an arbitrary 25percentile for putting some sites that support singletons
## I don't use a fixed probability because this should change with the number of
## organisms in the alignment
singlProp = quantile(lenProps[lenProps>0], probs=0.25)

## generate the singleton supporting sites
for(i in 1:n){
    patterns[i, length(sb)+i] = 1
    lenProps[length(sb)+i] = singlProp
}

## convert everything to DNA
## the convertion is random to two bases per site
alphabet=c("A" ,"C", "G", "T")
getData = function(pat, alphabet, p=1){
    tmp = sapply(1:length(pat), function(x){sample(c(pat[x], 1-pat[x]), 1, replace=F, prob=c(p, 1-p))})
    rchr = sample(alphabet, 2, replace=F)
    return(rchr[tmp+1])
}

## don't use the pattern 1111111 because it's monomorphic
cols = which(colSums(patterns) < nrow(patterns))
patToGet = sample(cols, size=ncol(dataMatrix), replace=TRUE, prob=lenProps[cols])

## the probability to keep a state as it was
## CHANGE HERE IF YOU WANT TO TEST OTHER VALUES
p = 0.75
#############
#############
## in the test dataset we copy a state from the pattern with a probability 0.75 correctly, or 0.25 erroneously
for(i in 1:ncol(dataMatrix)){
    dataMatrix[,i] = getData(patterns[,patToGet[i]], alphabet, p)
}
## the "perfect" dataset consists of "copying" each state from the pattern correctly
perfDataMatrix = dataMatrix
for(i in 1:ncol(dataMatrix)){
    perfDataMatrix[,i] = getData(patterns[,patToGet[i]], alphabet, 1)
}
## the "random" dataset consists of "copying" totally randomly each site
randDataMatrix = dataMatrix
for(i in 1:ncol(dataMatrix)){
    randDataMatrix[,i] = getData(patterns[,patToGet[i]], alphabet, .5)
}

## calculate the per-site likelihood
phydatcor = phyDat(perfDataMatrix, type="DNA")
siteLikesCor = pml(atree, data=phydatcor)
siteLikesCor$siteLik
phyldatrand = phyDat(randDataMatrix,type="DNA")
sitesLikesrand = pml(atree, data=phyldatrand)
sitesLikesrand$siteLik
phyldat = phyDat(dataMatrix,type="DNA")
sitesLikes = pml(atree, data=phyldat)
sitesLikes$siteLik

#####################################
## Get the ML trees
#####################################

## the test dataset
fit_mt = pml_bb(phyldat, "JC")
bs = bootstrap.pml(fit_mt, bs=50, optNni=TRUE)
## the random dataset
fit_mtrand = pml_bb(phyldatrand, "JC")
bsrand = bootstrap.pml(fit_mtrand, bs=50, optNni=TRUE)
## the test dataset X20
dataMatrix_x20 = dataMatrix
for(i in 1:19){
    dataMatrix_x20 = cbind(dataMatrix_x20, dataMatrix)
}
phyldat_x20 = phyDat(dataMatrix_x20, type="DNA")
fit_mt_x20 = pml_bb(phyldat_x20, "JC")
bs_x20 = bootstrap.pml(fit_mt_x20, bs=50, optNni=TRUE)

### RF Distances ################################################

## rf distance test dataset with the True tree
rfdist = RF.dist(unroot(atree), fit_mt$tree, normalize=TRUE)
## rf distance random with the True tree
rfdistrand = RF.dist(unroot(atree), fit_mtrand$tree, normalize=TRUE)
## rf distance x20 test with the True tree
rfdist_x20 = RF.dist(unroot(atree), fit_mt_x20$tree, normalize=TRUE)

## Parsimony site metrics
## A site that supports a subtree has a parsimony score of 1
## site metrics
parscore_true = parsimony(atree, phydatcor, method="fitch", site="site")
parscore_er2true = parsimony(atree, phyldat, method="fitch", site="site")
parscore_er2est =  parsimony(fit_mt$tree, phyldat, method="fitch", site="site")
parscore_rand2true =  parsimony(atree, phyldatrand, method="fitch", site="site")
parscore_rand2est =  parsimony(fit_mtrand$tree, phyldatrand, method="fitch", site="site")

## Put all  the parsimony scores in a list
parscores = list(ideal=parscore_true, wer2true=parscore_er2true, wer2est=parscore_er2est, rand2true=parscore_rand2true, rand2est=parscore_rand2est)

## generate the plot
pdf("data0.75_3000.pdf", height=20, width=25)
layout(matrix(1:6, nrow=2, byrow=TRUE))
boxplot(list(siteLikesCor$siteLik, sitesLikes$siteLik, sitesLikesrand$siteLik), names=c("Correct", "Errors", "Random"),  cex=2, cex.lab=2, cex.axis=2, main="A.\nSite Likelihoods")
plotBS(midpoint(fit_mt$tree), bs, type="p", cex=2, main=paste("B.\nprob ", p, "of correct state\nrf:", round(rfdist, 3)), cex.main=1)
plotBS(midpoint(fit_mtrand$tree), bsrand, type="p", cex=2, main=paste("C.\nRandom sites (p=0.5)\nrf:", rfdistrand), cex.main=1)
plot(atree, cex=2, main="D.\nTrue tree", cex.main=1, cex.axis=2)
boxplot(parscores, main="E.\nParsimony scores: ideal\nwith errors to true, with errors to estimated\nrandom to true, random to estimated", cex=2, cex.main=1, cex.lab=2, cex.axis=2)
plotBS(midpoint(fit_mt_x20$tree), bs_x20, type="p", cex=2, main=paste("F.\nProbability ", p, "of correct state\nrf:", round(rfdist_x20, 3), "\nX20 dataset"), cex.main=1)
dev.off()
